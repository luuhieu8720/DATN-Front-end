//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

var currentUser = JSON.parse(localStorage.getItem("currentUser") || '{}');

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = "https://localhost:44304";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authsPOST(body: LoginForm | undefined): Promise<TokenResponse> {
        let url_ = this.baseUrl + "/api/auths";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthsPOST(_response);
        });
    }

    protected processAuthsPOST(response: Response): Promise<TokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TokenResponse.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResponse>(null as any);
    }

    /**
     * @return Success
     */
    authsGET(): Promise<AuthenUser> {
        let url_ = this.baseUrl + "/api/auths";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthsGET(_response);
        });
    }

    protected processAuthsGET(response: Response): Promise<AuthenUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthenUser.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenUser>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST(body: CommentForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentsPOST(_response);
        });
    }

    protected processCommentsPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    commentsAll(): Promise<CommentItem[]> {
        let url_ = this.baseUrl + "/api/comments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentsAll(_response);
        });
    }

    protected processCommentsAll(response: Response): Promise<CommentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CommentItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentItem[]>(null as any);
    }

    /**
     * @return Success
     */
    commentsGET(id: string): Promise<CommentDetail> {
        let url_ = this.baseUrl + "/api/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentsGET(_response);
        });
    }

    protected processCommentsGET(response: Response): Promise<CommentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CommentDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT(id: string, body: CommentForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentsPUT(_response);
        });
    }

    protected processCommentsPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    departmentsAll(): Promise<DepartmentItem[]> {
        let url_ = this.baseUrl + "/api/departments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentsAll(_response);
        });
    }

    protected processDepartmentsAll(response: Response): Promise<DepartmentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(DepartmentItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    departmentsPOST(body: DepartmentForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/departments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentsPOST(_response);
        });
    }

    protected processDepartmentsPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    departmentsGET(id: string): Promise<DepartmentDetail> {
        let url_ = this.baseUrl + "/api/departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentsGET(_response);
        });
    }

    protected processDepartmentsGET(response: Response): Promise<DepartmentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = DepartmentDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    departmentsPUT(id: string, body: DepartmentForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentsPUT(_response);
        });
    }

    protected processDepartmentsPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    formstatusesAll(): Promise<FormStatusItem[]> {
        let url_ = this.baseUrl + "/api/formstatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormstatusesAll(_response);
        });
    }

    protected processFormstatusesAll(response: Response): Promise<FormStatusItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(FormStatusItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormStatusItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formstatusesPOST(body: FormStatusForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/formstatuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormstatusesPOST(_response);
        });
    }

    protected processFormstatusesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    formstatusesGET(id: number): Promise<FormStatusDetail> {
        let url_ = this.baseUrl + "/api/formstatuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormstatusesGET(_response);
        });
    }

    protected processFormstatusesGET(response: Response): Promise<FormStatusDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = FormStatusDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormStatusDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formstatusesPUT(id: number, body: FormStatusForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/formstatuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFormstatusesPUT(_response);
        });
    }

    protected processFormstatusesPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forget(email: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/password/forget?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForget(_response);
        });
    }

    protected processForget(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    change(body: ChangePasswordForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/password/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChange(_response);
        });
    }

    protected processChange(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePasswordForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/password/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    reportsAll(): Promise<ReportItem[]> {
        let url_ = this.baseUrl + "/api/reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReportsAll(_response);
        });
    }

    protected processReportsAll(response: Response): Promise<ReportItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ReportItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reportsPOST(body: ReportFormDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/reports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReportsPOST(_response);
        });
    }

    protected processReportsPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    reportsGET(id: string): Promise<ReportDetail> {
        let url_ = this.baseUrl + "/api/reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReportsGET(_response);
        });
    }

    protected processReportsGET(response: Response): Promise<ReportDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ReportDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reportsPUT(id: string, body: ReportFormDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReportsPUT(_response);
        });
    }

    protected processReportsPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    allGET(): Promise<ReportItem[]> {
        let url_ = this.baseUrl + "/api/reports/user/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAllGET(_response);
        });
    }

    protected processAllGET(response: Response): Promise<ReportItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ReportItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    allPOST(body: ReportsFilter | undefined): Promise<ReportItem[]> {
        let url_ = this.baseUrl + "/api/reports/filter/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAllPOST(_response);
        });
    }

    protected processAllPOST(response: Response): Promise<ReportItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ReportItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportItem[]>(null as any);
    }

    /**
     * @return Success
     */
    requestAll(): Promise<FormRequestItem[]> {
        let url_ = this.baseUrl + "/api/request";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestAll(_response);
        });
    }

    protected processRequestAll(response: Response): Promise<FormRequestItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(FormRequestItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormRequestItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestPOST(body: FormRequestForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestPOST(_response);
        });
    }

    protected processRequestPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    requestGET(id: string): Promise<FormRequestDetail> {
        let url_ = this.baseUrl + "/api/request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestGET(_response);
        });
    }

    protected processRequestGET(response: Response): Promise<FormRequestDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = FormRequestDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormRequestDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestPUT(id: string, body: FormRequestForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestPUT(_response);
        });
    }

    protected processRequestPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    filter(body: RequestsFilter | undefined): Promise<FormRequestDetail[]> {
        let url_ = this.baseUrl + "/api/request/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilter(_response);
        });
    }

    protected processFilter(response: Response): Promise<FormRequestDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(FormRequestDetail.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormRequestDetail[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    user(body: RequestsFilter | undefined): Promise<FormRequestDetail[]> {
        let url_ = this.baseUrl + "/api/request/filter/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<FormRequestDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(FormRequestDetail.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormRequestDetail[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    comfirm(id: string, body: FormRequestConfirm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/request/comfirm/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComfirm(_response);
        });
    }

    protected processComfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    timekeepingPOST(body: TimeKeepingForm | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/timekeeping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTimekeepingPOST(_response);
        });
    }

    protected processTimekeepingPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    timekeepingAll(): Promise<TimeKeepingItem[]> {
        let url_ = this.baseUrl + "/api/timekeeping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTimekeepingAll(_response);
        });
    }

    protected processTimekeepingAll(response: Response): Promise<TimeKeepingItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TimeKeepingItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeKeepingItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    timekeepingPUT(body: TimeKeepingForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/timekeeping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTimekeepingPUT(_response);
        });
    }

    protected processTimekeepingPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: string): Promise<TimeKeepingDetail> {
        let url_ = this.baseUrl + "/api/timekeeping/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetbyid(_response);
        });
    }

    protected processGetbyid(response: Response): Promise<TimeKeepingDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TimeKeepingDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeKeepingDetail>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    filter2(body: TimeKeepingFilter | undefined): Promise<TimeKeepingItem[]> {
        let url_ = this.baseUrl + "/api/timekeeping/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilter2(_response);
        });
    }

    protected processFilter2(response: Response): Promise<TimeKeepingItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TimeKeepingItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeKeepingItem[]>(null as any);
    }

    /**
     * @return Success
     */
    timekeepingAll2(userId: string): Promise<TimeKeepingItem[]> {
        let url_ = this.baseUrl + "/api/timekeeping/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTimekeepingAll2(_response);
        });
    }

    protected processTimekeepingAll2(response: Response): Promise<TimeKeepingItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TimeKeepingItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeKeepingItem[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    validate(userId: string | undefined): Promise<TimeKeepingDetail> {
        let url_ = this.baseUrl + "/api/timekeeping/validate?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<TimeKeepingDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TimeKeepingDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimeKeepingDetail>(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(id: string | undefined, body: FormRequestForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/timekeeping/punish/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    usersAll(): Promise<UserItem[]> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersAll(_response);
        });
    }

    protected processUsersAll(response: Response): Promise<UserItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UserItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body: UserFormCreate | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    manager(id: string | undefined): Promise<UserItem[]> {
        let url_ = this.baseUrl + "/api/users/manager?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManager(_response);
        });
    }

    protected processManager(response: Response): Promise<UserItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UserItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserItem[]>(null as any);
    }

    /**
     * @return Success
     */
    usersGET(id: string): Promise<UserDetail> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserDetail.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: string, body: UserFormUpdate | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    filter3(body: WorkingTimeFilter | undefined): Promise<WorkingTimeItem[]> {
        let url_ = this.baseUrl + "/api/workingtime/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilter3(_response);
        });
    }

    protected processFilter3(response: Response): Promise<WorkingTimeItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(WorkingTimeItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkingTimeItem[]>(null as any);
    }

    /**
     * @param dateTime (optional) 
     * @return Success
     */
    allGET2(dateTime: Date | undefined): Promise<WorkingTimeItem[]> {
        let url_ = this.baseUrl + "/api/workingtime/all?";
        if (dateTime === null)
            throw new Error("The parameter 'dateTime' cannot be null.");
        else if (dateTime !== undefined)
            url_ += "dateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAllGET2(_response);
        });
    }

    protected processAllGET2(response: Response): Promise<WorkingTimeItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(WorkingTimeItem.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkingTimeItem[]>(null as any);
    }

    /**
     * @param dateTime (optional) 
     * @return Success
     */
    workingtime(dateTime: Date | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/workingtime?";
        if (dateTime === null)
            throw new Error("The parameter 'dateTime' cannot be null.");
        else if (dateTime !== undefined)
            url_ += "dateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Authorization": "Bearer " + currentUser.token,
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWorkingtime(_response);
        });
    }

    protected processWorkingtime(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class LoginForm implements ILoginForm {
    emailOrUsername!: string;
    password!: string;

    constructor(data?: ILoginForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailOrUsername = _data["emailOrUsername"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginForm {
        data = typeof data === 'object' ? data : {};
        let result = new LoginForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailOrUsername"] = this.emailOrUsername;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginForm {
    emailOrUsername: string;
    password: string;
}

export enum Role {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TokenResponse implements ITokenResponse {
    token?: string | undefined;
    userId?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    role?: Role;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["username"] = this.username;
        data["role"] = this.role;
        return data;
    }
}

export interface ITokenResponse {
    token?: string | undefined;
    userId?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    role?: Role;
}

export class AuthenUser implements IAuthenUser {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    role?: Role;

    constructor(data?: IAuthenUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): AuthenUser {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["username"] = this.username;
        data["role"] = this.role;
        return data;
    }
}

export interface IAuthenUser {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    role?: Role;
}

export class CommentForm implements ICommentForm {
    reportId?: string;
    content?: string | undefined;
    commentedTime?: Date;
    userId?: string;

    constructor(data?: ICommentForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"];
            this.content = _data["content"];
            this.commentedTime = _data["commentedTime"] ? new Date(_data["commentedTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CommentForm {
        data = typeof data === 'object' ? data : {};
        let result = new CommentForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["content"] = this.content;
        data["commentedTime"] = this.commentedTime ? this.commentedTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICommentForm {
    reportId?: string;
    content?: string | undefined;
    commentedTime?: Date;
    userId?: string;
}

export class Department implements IDepartment {
    id?: string;
    name?: string | undefined;
    managerId?: string | undefined;
    manager?: User;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.managerId = _data["managerId"];
            this.manager = _data["manager"] ? User.fromJS(_data["manager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["managerId"] = this.managerId;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepartment {
    id?: string;
    name?: string | undefined;
    managerId?: string | undefined;
    manager?: User;
}

export class ForgetPassword implements IForgetPassword {
    id?: string;
    userId?: string;
    user?: User;
    code?: string | undefined;
    createDate?: Date;

    constructor(data?: IForgetPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.code = _data["code"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ForgetPassword {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IForgetPassword {
    id?: string;
    userId?: string;
    user?: User;
    code?: string | undefined;
    createDate?: Date;
}

export class User implements IUser {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    departmentId?: string | undefined;
    department?: Department;
    role?: Role;
    readonly forgetPasswords?: ForgetPassword[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.role = _data["role"];
            if (Array.isArray(_data["forgetPasswords"])) {
                (<any>this).forgetPasswords = [] as any;
                for (let item of _data["forgetPasswords"])
                    (<any>this).forgetPasswords!.push(ForgetPassword.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["role"] = this.role;
        if (Array.isArray(this.forgetPasswords)) {
            data["forgetPasswords"] = [];
            for (let item of this.forgetPasswords)
                data["forgetPasswords"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    email?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    departmentId?: string | undefined;
    department?: Department;
    role?: Role;
    forgetPasswords?: ForgetPassword[] | undefined;
}

export class CommentItem implements ICommentItem {
    reportId?: string;
    content?: string | undefined;
    commentedTime?: Date;
    userId?: string;
    commentedUser?: User;

    constructor(data?: ICommentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"];
            this.content = _data["content"];
            this.commentedTime = _data["commentedTime"] ? new Date(_data["commentedTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.commentedUser = _data["commentedUser"] ? User.fromJS(_data["commentedUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentItem {
        data = typeof data === 'object' ? data : {};
        let result = new CommentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["content"] = this.content;
        data["commentedTime"] = this.commentedTime ? this.commentedTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["commentedUser"] = this.commentedUser ? this.commentedUser.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentItem {
    reportId?: string;
    content?: string | undefined;
    commentedTime?: Date;
    userId?: string;
    commentedUser?: User;
}

export class CommentDetail implements ICommentDetail {
    reportId?: string;
    content?: string | undefined;
    commentedTime?: Date;
    userId?: string;
    commentedUser?: User;

    constructor(data?: ICommentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"];
            this.content = _data["content"];
            this.commentedTime = _data["commentedTime"] ? new Date(_data["commentedTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.commentedUser = _data["commentedUser"] ? User.fromJS(_data["commentedUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["content"] = this.content;
        data["commentedTime"] = this.commentedTime ? this.commentedTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["commentedUser"] = this.commentedUser ? this.commentedUser.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentDetail {
    reportId?: string;
    content?: string | undefined;
    commentedTime?: Date;
    userId?: string;
    commentedUser?: User;
}

export class UserShorted implements IUserShorted {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    password?: string | undefined;
    departmentId?: string | undefined;
    role?: Role;

    constructor(data?: IUserShorted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.username = _data["username"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.password = _data["password"];
            this.departmentId = _data["departmentId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserShorted {
        data = typeof data === 'object' ? data : {};
        let result = new UserShorted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["username"] = this.username;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["password"] = this.password;
        data["departmentId"] = this.departmentId;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserShorted {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    password?: string | undefined;
    departmentId?: string | undefined;
    role?: Role;
}

export class DepartmentItem implements IDepartmentItem {
    id?: string;
    name?: string | undefined;
    managerId?: string | undefined;
    manager?: UserShorted;

    constructor(data?: IDepartmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.managerId = _data["managerId"];
            this.manager = _data["manager"] ? UserShorted.fromJS(_data["manager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DepartmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["managerId"] = this.managerId;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepartmentItem {
    id?: string;
    name?: string | undefined;
    managerId?: string | undefined;
    manager?: UserShorted;
}

export class DepartmentForm implements IDepartmentForm {
    name!: string;
    managerId?: string | undefined;

    constructor(data?: IDepartmentForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.managerId = _data["managerId"];
        }
    }

    static fromJS(data: any): DepartmentForm {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["managerId"] = this.managerId;
        return data;
    }
}

export interface IDepartmentForm {
    name: string;
    managerId?: string | undefined;
}

export class UserDetail implements IUserDetail {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    password?: string | undefined;
    departmentId?: string | undefined;
    department?: Department;
    role?: Role;

    constructor(data?: IUserDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.username = _data["username"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.password = _data["password"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["username"] = this.username;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["password"] = this.password;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserDetail {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    password?: string | undefined;
    departmentId?: string | undefined;
    department?: Department;
    role?: Role;
}

export class DepartmentDetail implements IDepartmentDetail {
    id?: string;
    name?: string | undefined;
    managerId?: string | undefined;
    manager?: UserDetail;

    constructor(data?: IDepartmentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.managerId = _data["managerId"];
            this.manager = _data["manager"] ? UserDetail.fromJS(_data["manager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DepartmentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["managerId"] = this.managerId;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepartmentDetail {
    id?: string;
    name?: string | undefined;
    managerId?: string | undefined;
    manager?: UserDetail;
}

export class FormStatusItem implements IFormStatusItem {
    id?: number;
    status?: string | undefined;

    constructor(data?: IFormStatusItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FormStatusItem {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatusItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IFormStatusItem {
    id?: number;
    status?: string | undefined;
}

export class FormStatusForm implements IFormStatusForm {
    status?: string | undefined;

    constructor(data?: IFormStatusForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FormStatusForm {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatusForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IFormStatusForm {
    status?: string | undefined;
}

export class FormStatusDetail implements IFormStatusDetail {
    id?: number;
    status?: string | undefined;

    constructor(data?: IFormStatusDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FormStatusDetail {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatusDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IFormStatusDetail {
    id?: number;
    status?: string | undefined;
}

export class ChangePasswordForm implements IChangePasswordForm {
    code?: string | undefined;
    email?: string | undefined;
    password!: string;

    constructor(data?: IChangePasswordForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ChangePasswordForm {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IChangePasswordForm {
    code?: string | undefined;
    email?: string | undefined;
    password: string;
}

export class UpdatePasswordForm implements IUpdatePasswordForm {
    oldPassword!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IUpdatePasswordForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordForm {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IUpdatePasswordForm {
    oldPassword: string;
    password: string;
    confirmPassword: string;
}

export class Report implements IReport {
    id?: string;
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
    user?: User;
    comments?: Comment[] | undefined;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.updatedTime = _data["updatedTime"] ? new Date(_data["updatedTime"].toString()) : <any>undefined;
            this.uploadFileLink = _data["uploadFileLink"];
            this.content = _data["content"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["updatedTime"] = this.updatedTime ? this.updatedTime.toISOString() : <any>undefined;
        data["uploadFileLink"] = this.uploadFileLink;
        data["content"] = this.content;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReport {
    id?: string;
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
    user?: User;
    comments?: Comment[] | undefined;
}

export class Comment implements IComment {
    id?: string;
    userId?: string;
    commentedUser?: User;
    reportId?: string;
    report?: Report;
    content?: string | undefined;
    commentedTime?: Date;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.commentedUser = _data["commentedUser"] ? User.fromJS(_data["commentedUser"]) : <any>undefined;
            this.reportId = _data["reportId"];
            this.report = _data["report"] ? Report.fromJS(_data["report"]) : <any>undefined;
            this.content = _data["content"];
            this.commentedTime = _data["commentedTime"] ? new Date(_data["commentedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["commentedUser"] = this.commentedUser ? this.commentedUser.toJSON() : <any>undefined;
        data["reportId"] = this.reportId;
        data["report"] = this.report ? this.report.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["commentedTime"] = this.commentedTime ? this.commentedTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IComment {
    id?: string;
    userId?: string;
    commentedUser?: User;
    reportId?: string;
    report?: Report;
    content?: string | undefined;
    commentedTime?: Date;
}

export class ReportItem implements IReportItem {
    id?: string;
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
    user?: User;
    comments?: Comment[] | undefined;

    constructor(data?: IReportItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.updatedTime = _data["updatedTime"] ? new Date(_data["updatedTime"].toString()) : <any>undefined;
            this.uploadFileLink = _data["uploadFileLink"];
            this.content = _data["content"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportItem {
        data = typeof data === 'object' ? data : {};
        let result = new ReportItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["updatedTime"] = this.updatedTime ? this.updatedTime.toISOString() : <any>undefined;
        data["uploadFileLink"] = this.uploadFileLink;
        data["content"] = this.content;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportItem {
    id?: string;
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
    user?: User;
    comments?: Comment[] | undefined;
}

export class ReportFormDto implements IReportFormDto {
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;

    constructor(data?: IReportFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.updatedTime = _data["updatedTime"] ? new Date(_data["updatedTime"].toString()) : <any>undefined;
            this.uploadFileLink = _data["uploadFileLink"];
            this.content = _data["content"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ReportFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["updatedTime"] = this.updatedTime ? this.updatedTime.toISOString() : <any>undefined;
        data["uploadFileLink"] = this.uploadFileLink;
        data["content"] = this.content;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IReportFormDto {
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
}

export class ReportDetail implements IReportDetail {
    id?: string;
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
    user?: User;
    comments?: Comment[] | undefined;

    constructor(data?: IReportDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.updatedTime = _data["updatedTime"] ? new Date(_data["updatedTime"].toString()) : <any>undefined;
            this.uploadFileLink = _data["uploadFileLink"];
            this.content = _data["content"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["updatedTime"] = this.updatedTime ? this.updatedTime.toISOString() : <any>undefined;
        data["uploadFileLink"] = this.uploadFileLink;
        data["content"] = this.content;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportDetail {
    id?: string;
    createdTime?: Date;
    updatedTime?: Date | undefined;
    uploadFileLink?: string | undefined;
    content?: string | undefined;
    userId?: string;
    user?: User;
    comments?: Comment[] | undefined;
}

export class ReportsFilter implements IReportsFilter {
    departmentId?: string | undefined;
    userId?: string | undefined;
    dateTime?: Date | undefined;

    constructor(data?: IReportsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentId = _data["departmentId"];
            this.userId = _data["userId"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReportsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ReportsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentId"] = this.departmentId;
        data["userId"] = this.userId;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IReportsFilter {
    departmentId?: string | undefined;
    userId?: string | undefined;
    dateTime?: Date | undefined;
}

export class FormStatus implements IFormStatus {
    id?: number;
    status?: string | undefined;

    constructor(data?: IFormStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FormStatus {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IFormStatus {
    id?: number;
    status?: string | undefined;
}

export class RequestType implements IRequestType {
    id?: number;
    typeName?: string | undefined;

    constructor(data?: IRequestType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        return data;
    }
}

export interface IRequestType {
    id?: number;
    typeName?: string | undefined;
}

export class FormRequestItem implements IFormRequestItem {
    id?: string;
    content?: string | undefined;
    reason?: string | undefined;
    hours?: number | undefined;
    submittedTime?: Date;
    userId?: string;
    user?: User;
    requestDate?: Date;
    statusId?: number;
    formStatus?: FormStatus;
    requestTypeId?: number;
    requestType?: RequestType;

    constructor(data?: IFormRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.reason = _data["reason"];
            this.hours = _data["hours"];
            this.submittedTime = _data["submittedTime"] ? new Date(_data["submittedTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.formStatus = _data["formStatus"] ? FormStatus.fromJS(_data["formStatus"]) : <any>undefined;
            this.requestTypeId = _data["requestTypeId"];
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FormRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new FormRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["reason"] = this.reason;
        data["hours"] = this.hours;
        data["submittedTime"] = this.submittedTime ? this.submittedTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["formStatus"] = this.formStatus ? this.formStatus.toJSON() : <any>undefined;
        data["requestTypeId"] = this.requestTypeId;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFormRequestItem {
    id?: string;
    content?: string | undefined;
    reason?: string | undefined;
    hours?: number | undefined;
    submittedTime?: Date;
    userId?: string;
    user?: User;
    requestDate?: Date;
    statusId?: number;
    formStatus?: FormStatus;
    requestTypeId?: number;
    requestType?: RequestType;
}

export class FormRequestForm implements IFormRequestForm {
    content?: string | undefined;
    reason?: string | undefined;
    hours?: number | undefined;
    submittedTime?: Date;
    updatedTime?: Date;
    requestDate?: Date;
    userId?: string;
    statusId?: number;
    requestTypeId?: number;

    constructor(data?: IFormRequestForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.reason = _data["reason"];
            this.hours = _data["hours"];
            this.submittedTime = _data["submittedTime"] ? new Date(_data["submittedTime"].toString()) : <any>undefined;
            this.updatedTime = _data["updatedTime"] ? new Date(_data["updatedTime"].toString()) : <any>undefined;
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.statusId = _data["statusId"];
            this.requestTypeId = _data["requestTypeId"];
        }
    }

    static fromJS(data: any): FormRequestForm {
        data = typeof data === 'object' ? data : {};
        let result = new FormRequestForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["reason"] = this.reason;
        data["hours"] = this.hours;
        data["submittedTime"] = this.submittedTime ? this.submittedTime.toISOString() : <any>undefined;
        data["updatedTime"] = this.updatedTime ? this.updatedTime.toISOString() : <any>undefined;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["statusId"] = this.statusId;
        data["requestTypeId"] = this.requestTypeId;
        return data;
    }
}

export interface IFormRequestForm {
    content?: string | undefined;
    reason?: string | undefined;
    hours?: number | undefined;
    submittedTime?: Date;
    updatedTime?: Date;
    requestDate?: Date;
    userId?: string;
    statusId?: number;
    requestTypeId?: number;
}

export class FormRequestDetail implements IFormRequestDetail {
    id?: string;
    content?: string | undefined;
    reason?: string | undefined;
    hours?: number | undefined;
    submittedTime?: Date;
    userId?: string;
    user?: User;
    requestDate?: Date;
    statusId?: number;
    formStatus?: FormStatus;
    requestTypeId?: number;
    requestType?: RequestType;

    constructor(data?: IFormRequestDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.reason = _data["reason"];
            this.hours = _data["hours"];
            this.submittedTime = _data["submittedTime"] ? new Date(_data["submittedTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.formStatus = _data["formStatus"] ? FormStatus.fromJS(_data["formStatus"]) : <any>undefined;
            this.requestTypeId = _data["requestTypeId"];
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FormRequestDetail {
        data = typeof data === 'object' ? data : {};
        let result = new FormRequestDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["reason"] = this.reason;
        data["hours"] = this.hours;
        data["submittedTime"] = this.submittedTime ? this.submittedTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["formStatus"] = this.formStatus ? this.formStatus.toJSON() : <any>undefined;
        data["requestTypeId"] = this.requestTypeId;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFormRequestDetail {
    id?: string;
    content?: string | undefined;
    reason?: string | undefined;
    hours?: number | undefined;
    submittedTime?: Date;
    userId?: string;
    user?: User;
    requestDate?: Date;
    statusId?: number;
    formStatus?: FormStatus;
    requestTypeId?: number;
    requestType?: RequestType;
}

export class RequestsFilter implements IRequestsFilter {
    departmentId?: string | undefined;
    userId?: string | undefined;
    formStatusId?: number | undefined;
    dateTime?: Date | undefined;

    constructor(data?: IRequestsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentId = _data["departmentId"];
            this.userId = _data["userId"];
            this.formStatusId = _data["formStatusId"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new RequestsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentId"] = this.departmentId;
        data["userId"] = this.userId;
        data["formStatusId"] = this.formStatusId;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRequestsFilter {
    departmentId?: string | undefined;
    userId?: string | undefined;
    formStatusId?: number | undefined;
    dateTime?: Date | undefined;
}

export class FormRequestConfirm implements IFormRequestConfirm {
    statusId?: number;

    constructor(data?: IFormRequestConfirm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): FormRequestConfirm {
        data = typeof data === 'object' ? data : {};
        let result = new FormRequestConfirm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusId"] = this.statusId;
        return data;
    }
}

export interface IFormRequestConfirm {
    statusId?: number;
}

export class TimeKeepingForm implements ITimeKeepingForm {
    checkinTime?: Date | undefined;
    checkoutTime?: Date | undefined;
    userId?: string;
    isPunished?: boolean;
    punishedTime?: number;

    constructor(data?: ITimeKeepingForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkinTime = _data["checkinTime"] ? new Date(_data["checkinTime"].toString()) : <any>undefined;
            this.checkoutTime = _data["checkoutTime"] ? new Date(_data["checkoutTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isPunished = _data["isPunished"];
            this.punishedTime = _data["punishedTime"];
        }
    }

    static fromJS(data: any): TimeKeepingForm {
        data = typeof data === 'object' ? data : {};
        let result = new TimeKeepingForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkinTime"] = this.checkinTime ? this.checkinTime.toISOString() : <any>undefined;
        data["checkoutTime"] = this.checkoutTime ? this.checkoutTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isPunished"] = this.isPunished;
        data["punishedTime"] = this.punishedTime;
        return data;
    }
}

export interface ITimeKeepingForm {
    checkinTime?: Date | undefined;
    checkoutTime?: Date | undefined;
    userId?: string;
    isPunished?: boolean;
    punishedTime?: number;
}

export class TimeKeepingItem implements ITimeKeepingItem {
    checkinTime?: Date | undefined;
    checkoutTime?: Date | undefined;
    userId?: string;
    user?: User;
    isPunished?: boolean;
    punishedTime?: number;

    constructor(data?: ITimeKeepingItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkinTime = _data["checkinTime"] ? new Date(_data["checkinTime"].toString()) : <any>undefined;
            this.checkoutTime = _data["checkoutTime"] ? new Date(_data["checkoutTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.isPunished = _data["isPunished"];
            this.punishedTime = _data["punishedTime"];
        }
    }

    static fromJS(data: any): TimeKeepingItem {
        data = typeof data === 'object' ? data : {};
        let result = new TimeKeepingItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkinTime"] = this.checkinTime ? this.checkinTime.toISOString() : <any>undefined;
        data["checkoutTime"] = this.checkoutTime ? this.checkoutTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["isPunished"] = this.isPunished;
        data["punishedTime"] = this.punishedTime;
        return data;
    }
}

export interface ITimeKeepingItem {
    checkinTime?: Date | undefined;
    checkoutTime?: Date | undefined;
    userId?: string;
    user?: User;
    isPunished?: boolean;
    punishedTime?: number;
}

export class TimeKeepingDetail implements ITimeKeepingDetail {
    checkinTime?: Date | undefined;
    checkoutTime?: Date | undefined;
    userId?: string;
    user?: User;
    isPunished?: boolean;
    punishedTime?: number;

    constructor(data?: ITimeKeepingDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkinTime = _data["checkinTime"] ? new Date(_data["checkinTime"].toString()) : <any>undefined;
            this.checkoutTime = _data["checkoutTime"] ? new Date(_data["checkoutTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.isPunished = _data["isPunished"];
            this.punishedTime = _data["punishedTime"];
        }
    }

    static fromJS(data: any): TimeKeepingDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TimeKeepingDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkinTime"] = this.checkinTime ? this.checkinTime.toISOString() : <any>undefined;
        data["checkoutTime"] = this.checkoutTime ? this.checkoutTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["isPunished"] = this.isPunished;
        data["punishedTime"] = this.punishedTime;
        return data;
    }
}

export interface ITimeKeepingDetail {
    checkinTime?: Date | undefined;
    checkoutTime?: Date | undefined;
    userId?: string;
    user?: User;
    isPunished?: boolean;
    punishedTime?: number;
}

export class TimeKeepingFilter implements ITimeKeepingFilter {
    dateTime?: Date | undefined;
    userId?: string | undefined;
    departmentId?: string | undefined;

    constructor(data?: ITimeKeepingFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): TimeKeepingFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TimeKeepingFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["departmentId"] = this.departmentId;
        return data;
    }
}

export interface ITimeKeepingFilter {
    dateTime?: Date | undefined;
    userId?: string | undefined;
    departmentId?: string | undefined;
}

export class UserItem implements IUserItem {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    password?: string | undefined;
    departmentId?: string | undefined;
    department?: Department;
    role?: Role;

    constructor(data?: IUserItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.username = _data["username"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.password = _data["password"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["username"] = this.username;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["password"] = this.password;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserItem {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    password?: string | undefined;
    departmentId?: string | undefined;
    department?: Department;
    role?: Role;
}

export class UserFormCreate implements IUserFormCreate {
    username!: string;
    firstName!: string;
    lastName!: string;
    dateOfBirth!: Date;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    email!: string;
    password!: string;
    departmentId?: string | undefined;
    role?: Role;

    constructor(data?: IUserFormCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.departmentId = _data["departmentId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserFormCreate {
        data = typeof data === 'object' ? data : {};
        let result = new UserFormCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["email"] = this.email;
        data["password"] = this.password;
        data["departmentId"] = this.departmentId;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserFormCreate {
    username: string;
    firstName: string;
    lastName: string;
    dateOfBirth: Date;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    email: string;
    password: string;
    departmentId?: string | undefined;
    role?: Role;
}

export class UserFormUpdate implements IUserFormUpdate {
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    email?: string | undefined;
    departmentId?: string | undefined;
    role?: Role;

    constructor(data?: IUserFormUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.email = _data["email"];
            this.departmentId = _data["departmentId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserFormUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new UserFormUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["email"] = this.email;
        data["departmentId"] = this.departmentId;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserFormUpdate {
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    avatarUrl?: string | undefined;
    email?: string | undefined;
    departmentId?: string | undefined;
    role?: Role;
}

export class WorkingTimeFilter implements IWorkingTimeFilter {
    dateTime?: Date | undefined;
    userId?: string | undefined;
    departmentId?: string | undefined;

    constructor(data?: IWorkingTimeFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): WorkingTimeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingTimeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["departmentId"] = this.departmentId;
        return data;
    }
}

export interface IWorkingTimeFilter {
    dateTime?: Date | undefined;
    userId?: string | undefined;
    departmentId?: string | undefined;
}

export class WorkingTimeItem implements IWorkingTimeItem {
    time?: number;
    userId?: string;
    user?: User;
    punishedTime?: number;

    constructor(data?: IWorkingTimeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.punishedTime = _data["punishedTime"];
        }
    }

    static fromJS(data: any): WorkingTimeItem {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingTimeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["punishedTime"] = this.punishedTime;
        return data;
    }
}

export interface IWorkingTimeItem {
    time?: number;
    userId?: string;
    user?: User;
    punishedTime?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}